# Запуск проекта:

```
npm install
npm run dev
```

##Константы: `/constants.ts`
Там можно менять искусственную задержку для запросов к API, и интервал прихода новых сообщений

# Комментарии

###1. Выбор state-менеджера.

Я выбрал Zustand, потому что он хорошо подходит для легковесного проекта, хорошо работает с typescript, хорошо документирован и требует меньше шаблонного кода.

###2. Виртуализация.
Здесь мой выбор - react-virtuoso, потому что с этой задачей он справился лучше чем react-window или react-virtualized. Главным образом - более адекватное поведение скролла, и автоматическое подстраивание под размер.

###3. Архитектура - упрощенная FSD. В данном случае больше и не надо.

###4. Что еще было реализовано:

- Кнопка скролла вниз со счетчиком непрочитанных сообщений

###5. Потенциальные улучшения.

- _Дублирование сообщений._ Сообщение может стать неконсистентным, если сервер его принял, но до клиента не дошёл ответ сервера. В таком случае на клиенте сообщение останется в состоянии "не отправлено". Если повторить отправку - оно задублируется. Такую проблему я наблюдал во многих мессенджерах. Решение - использовать криптографически надежный локально сгенерированный id для проверки на дублирование.

- _Синхронизация оффлайн и онлайн истории._ В реальной ситуации прошлые сообщения могут быть изменены или удалены. Для этого можно использовать готовые решения (Pocketbase, Dexie).

- _Хранение данных на клиенте и потенциальные проблемы._

> Моё решение здесь - сохранять сообщения в общий кэш, который никогда не очищается. Проблемы: утечка памяти.

> Другое возможное решение - хранить сообщения только текущего чата. Проблемы: пользователь при переходе в новый чат будет каждый раз ждать загрузки всех сообщений.

> Решение: LRU-кэш с временем жизни (TTL). Сообщения хранятся на клиенте до тех пор, пока кэш не переполится, или пока время жизни чата не истечет.
> Вариант избежать утечек памяти: Хранить данные в IndexedDB. Иметь кэш первого уровня (память), второго уровня (IndexedDB) и третьего уровня (бэкенд).
