# Запуск проекта:

```
npm install
npm run dev
```

##Константы: `/constants.ts`
API_AVERAGE_DELAY - искуственная задержка ответов api
INCOMING_MESSAGE_INTERVAL - интервал прихода новых сообщений

# Комментарии

###1. Выбор state-менеджера.

Я выбрал Zustand, потому что он хорошо подходит для легковесного проекта, хорошо работает с typescript, хорошо документирован и требует меньше шаблонного кода.

###2. Виртуализация.
Здесь мой выбор - react-virtuoso, потому что с этой задачей он справился лучше чем react-window или react-virtualized. Главным образом - более адекватное поведение скролла, и автоматическое подстраивание под размер.

###3. Архитектура - упрощенная FSD.

###4. Потенциальные улучшения.

- _Дублирование сообщений._ Сообщение может стать неконсистентным, если сервер его принял, но до клиента не дошёл ответ сервера. В таком случае на клиенте сообщение останется в состоянии "не отправлено". Если повторить отправку - оно задублируется. Такую проблему я наблюдал во многих мессенджерах. Решение - использовать локально сгенерированный id для проверки на дублирование.

- _Синхронизация оффлайн и онлайн истории._ В реальной ситуации прошлые сообщения могут быть изменены или удалены. Для этого можно использовать готовые решения (Pocketbase, Dexie).

- _Хранение данных на клиенте и потенциальные проблемы._

> В текущей реализации хранятся только сообщения текущего чата. Проблемы: пользователь при переходе в новый чат будет каждый раз ждать загрузки всех сообщений. Можно также сохранять сообщения в общий кэш, который никогда не очищается, но это может вызвать утечки памяти.

> Решение: LRU-кэш с временем жизни (TTL). Сообщения хранятся на клиенте до тех пор, пока кэш не переполится, или пока время жизни чата не истечет.
> Вариант избежать утечек памяти: Хранить данные в IndexedDB. Иметь кэш первого уровня (память), второго уровня (IndexedDB) и третьего уровня (бэкенд).
